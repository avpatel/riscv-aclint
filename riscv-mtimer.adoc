// SPDX-License-Identifier: CC-BY-4.0
[[riscv-doc-template]]
:description: RISC-V Platform Specification for MTIMER
:company: RISC-V
:revdate:  February 03, 2022
:revnumber: 1.0-draft1 (stable)
:revremark: This document is in Draft state.  Change should be expected.
:url-riscv: http://riscv.org
:doctype: book
:preface-title: Preamble
:colophon:
:appendix-caption: Appendix
:imagesdir: images
:title-logo-image: image:riscv-images/risc-v_logo.png[pdfwidth=3.25in,align=center]
// Settings:
:experimental:
:reproducible:
:WaveDromEditorApp: wavedrom-cli
:imagesoutdir: images
:icons: font
:lang: en
:listing-caption: Listing
:sectnums:
:sectnumlevels: 5
:toclevels: 5
:toc: left
:source-highlighter: pygments
ifdef::backend-pdf[]
:source-highlighter: coderay
endif::[]
:data-uri:
:hide-uri-scheme:
:stem: latexmath
:footnote:
:xrefstyle: short 

= RISC-V Machine Level Timer Specification
:author: RISC-V Platform Specification Task Group
:email: tech-unixplatformspec@lists.riscv.org

// Preamble
[WARNING]
.This document is in the link:http://riscv.org/spec-state[Draft state]
====
Assume everything can change. This draft specification will change before 
being accepted as standard, so implementations made to this draft 
specification will likely not conform to the future standard.
====

// Table of contents
toc::[]

[preface]
== Copyright and license information

This RISC-V MTIMER specification has been contributed directly or
indirectly by:

[%hardbreaks]
* Greg Favor <gfavor@ventanamicro.com>
* Anup Patel <apatel@ventanamicro.com>

*NOTE:* Please add yourself to the above list if you have contributed to
the RISC-V MTIMER specification.

It is licensed under the Creative Commons Attribution 4.0 International
License (CC-BY 4.0). The full license text is available at
https://creativecommons.org/licenses/by/4.0/.

== Introduction

This RISC-V Machine Level Timer (MTIMER) specification defines a memory
mapped device which provides timer functionality for each HART of a RISC-V
platform. The timer functionality is required by operating systems,
bootloaders and firmwares for tracking time on a RISC-V platform.

The MTIMER device provides machine-level timer functionality for a set of
HARTs on a RISC-V platform. It has a single fixed-frequency monotonic time
counter (*MTIME*) register and a time compare register (*MTIMECMP*) for
each HART connected to the MTIMER device. A MTIMER device not connected
to any HART should only have a MTIME register and no MTIMECMP registers.

On a RISC-V platform with multiple MTIMER devices:

* Each MTIMER device provides machine-level timer functionality for a different
(or disjoint) set of HARTs. A MTIMER device assigns a HART index starting
from zero to each HART associated with it. The HART index assigned to a HART
by the MTIMER device may or may not have any relationship with the unique
HART identifier (*hart ID*) that the RISC-V Privileged Architecture assigns
to the HART.
* The MTIMECMP registers of a MTIMER device must only compare against the
MTIME register of the same MTIMER device for generating machine-level timer
interrupt.

The MTIMER device has a very flexible register layout where each register
can be placed at a separate 64-bit aligned physical address.

There is no limit on the maximum number of HARTs supported by a single MTIMER
device because of above described register 


== MTIMER Register Layout

The <<table_mtimer_register_list>> below shows map of the MTIME
register whereas the <<table_mtimer_compare_register_list>> below
shows map of the MTIMECMP registers relative to separate base addresses.

[#table_mtimer_register_list]
.MTIMER Time Register Map
[cols="2,1,1,6", width=95%, align="center", options="header"]
|===
| NAME        | Width | Attr | EDescription
| MTIME       | 8B    | RW   | Machine-level time counter
| MTIMECMP0   | 8B    | RW   | HART index 0 machine-level time compare
| MTIMECMP1   | 8B    | RW   | HART index 1 machine-level time compare
| ...         | ...   | ...  | ...
|===

=== MTIME Register

The MTIME register is a 64-bit little-endian read-write register that contains
the number of cycles counted based on a fixed reference frequency.

On MTIMER device reset, the MTIME register is cleared to zero.

=== MTIMECMP Registers

The MTIMECMP registers are per-HART 64-bit little-endian read-write registers.
It contains the MTIME register value at which machine-level timer interrupt
is to be triggered for the corresponding HART.

The machine-level timer interrupt of a HART is pending whenever MTIME is
greater than or equal to the value in the corresponding MTIMECMP register
whereas the machine-level timer interrupt of a HART is cleared whenever
MTIME is less than the value of the corresponding MTIMECMP register. The
machine-level timer interrupt is reflected in the MTIP bit of the `mip`
CSR.

On MTIMER device reset, the MTIMECMP registers are in unknown state.

== Synchronizing Multiple MTIME Registers

A RISC-V platform can have multiple HARTs grouped into hierarchical topology
groups (such as clusters, nodes, or sockets) where each topology group has
it's own MTIMER device. Further, such RISC-V platforms can also allow
clock-gating or powering off for a topology group (including the MTIMER
device) at runtime.

On a RISC-V platform with multiple MTIMER devices residing on the same die,
each device must satisfy the RISC-V architectural requirement that all the
MTIME registers with respect to each other, and all the per-HART `time` CSRs
with respect to each other, are synchronized to within one MTIME tick period.
For example, if the MTIME tick period is 10ns, then the MTIME registers, and
their associated time CSRs, should respectively be synchronized to within
10ns of each other.

On a RISC-V platform with multiple MTIMER devices on different die, the
MTIME registers (and their associated `time` CSRs) on different die may be
synchronized to only within a specified interval of each other that is larger
than the MTIME tick period. A platform may define a maximum allowed interval.

To satisfy the preceding MTIME synchronization requirements:

* All MTIME registers should have the same input clock so as to avoid runtime
  drift between separate MTIME registers (and their associated `time` CSRs)
* Upon system reset, the hardware must initialize and synchronize all MTIME
  registers to zero
* When a MTIMER device is stopped and started again due to, say, power
  management actions, the software should re-synchronize this MTIME register 
  with all other MTIME registers

When software updates one, multiple, or all MTIME registers, it must maintain
the preceding synchronization requirements (through measuring and then taking
into account the differing latencies of performing reads or writes to the
different MTIME registers).

As an example, the below RISC-V 64-bit assembly sequence can be used by
software to synchronize a MTIME register with reference to another MTIME
register.

[#source_sync_mtime_registers]
.Synchronizing a MTIME Registers On RISC-V 64-bit Platform
[source, assembly]
----
/*
 * unsigned long mtime_sync(unsigned long target_mtime_address,
 *                          unsigned long reference_mtime_address)
 */
        .globl mtime_sync
mtime_sync:
        /* Read target MTIME register in T0 register */
        ld        t0, (a0)
        fence     i, i

        /* Read reference MTIME register in T1 register */
        ld        t1, (a1)
        fence     i, i

        /* Read target MTIME register in T2 register */
        ld        t2, (a0)
        fence     i, i

        /*
         * Compute target MTIME adjustment in T3 register
         * T3 = T1 - ((T0 + T2) / 2)
         */
        srli      t0, t0, 1
        srli      t2, t2, 1
        add       t3, t0, t2
        sub       t3, t1, t3

        /* Update target MTIME register */
        ld        t4, (a0)
        add       t4, t4, t3
        sd        t4, (a0)

        /* Return MTIME adjustment value */
        add       a0, t3, zero

        ret
----

[sidebar]
--
[underline]*_NOTE_*: On some RISC-V platforms, the MTIME synchronization
sequence (i.e. the `mtime_sync()` function above) will need to be
repeated few times until delta between target MTIME register and reference
MTIME register is zero (or very close to zero).
--
